---
layout: default
title: 重写Android Priority JobQueue并总结经验(翻译)
category: 
comments: true
---

# 重写Android Priority JobQueue并总结经验(翻译)


2016年早春,我决定了要重构一个四年前我在[Path](https://path.com)工作的时候为了让app能有良好的离线体验而写的一个任务队列:[Android Priority JobQueue](https://github.com/yigit/android-priority-jobqueue)的内核.


经历了四个春夏秋冬，它已经从一个简单的任务队列管理系统成长为一个可以精准控制后台任务运行的复杂的任务队列管理系统.同时，安卓生态环境也跟随着改变了不少，尤其是[JobScheduler](https://developer.android.com/reference/android/app/job/JobScheduler.html)的出现.


由于在早期开发的时候做出了一些错误的决定导致了现在很难继续维护这份代码让它很好地适应安卓生态环境的发展.现在我已经完成了它的重构了，所以我觉得应该分享一下重构的经验并希望它在重构之后可以有一个更好的发展.



## 不要用共享内存来做线程间通讯;用消息传递来做共享内存


这个是这次重构里面最重要的一个任务,也是我在开发上一个版本的时候做的最错的一个决定.任务管理者天生就是多线程的，它必须能够并行运行多个任务.所以将需要共享的资源用一个线程锁来锁住是最常见的做法,这样同一时间就只有一个线程可以访问这个资源.刚开始的时候这样做没有出现任何问题,到后来就变得不可控制了，尤其是当你将访问这些共享资源的api开放出去之后.上一个版本的任务管理者也有一些关于线程锁的bug是几乎没有任何办法可以解决.同时 还有一些非常难管理的小问题:你要小心地处理内存屏障或者将某些必要的变量标记为```volatile```.

在新版本里面我将这些共享资源的方法完全改了从而让任务管理者变为单线程.任务管理者在它自己的一个线程里面运行着，这个线程是唯一一个可以访问共享资源的线程.在其他线程里面运行的任务只能通过线程间通讯来跟任务管理者沟通.而且它们并不能访问共享资源，实际上它们完全没有任何方法可以拿到共享资源的内存引用,这样就避免了以后再在这个地方出bug.就像是任务消费者一样,跟任务执行者一样所有的公开
api都用这样的消息传递方法来跟任务管理者沟通.

这样做也是有它的缺点的.在开发新版本的时候就发现了这样一个bug:在任务管理者跟任务执行者之前创建了一个消息传递无限循环,导致任务管理者一直在运行着.相对于死锁这个问题就简单得多了，只需要将初始化消息传递的对象限制为任务管理者就可以了.


# 抽象化所有跟计时有关的代码

任务管理者提供了延时执行任务的功能.java有内建的推迟运行东西或者获取当前时间的功能.实用java内建模块非常爽,但是等到你在持续集成服务器上跑测试代码时你'可靠'的代码就变得不可靠了.或者说,它们本来就是不可靠,只是你不知道而已.而且你也没有办法去测试资源竞争问题,因为你没有办法去控制时间.

在新版本里面,我把所有跟计时相关的东西都抽象到了一个Helper类里面了.我甚至写了一个lint checks来保证真实时间永远都不会被直接访问.这个抽象层不但抽象了```System.nanotime```的方法调用,而且还抽象了消息队列延迟时间和所有在代码里面用到过的计时器.

当然这样做也增加了不使用真实时间来做测试而带来的风险.但是也可以用真实时间来测试这个相对来说比较简单的抽象层以减轻它带来的风险.

# 加新api前三思而后行

这是我在维护安卓框架时候看到了安卓框架里面里面有那么多完全不合理或者是没有为灵活性充分考虑的代码的时候总结出来的经验.任务管理者也有类似的api,最糟糕的一个是只有当使用了```persistent```属性时候才返回一个唯一的```long```类型的id的```addJob```方法.导致了持久化的任务跟非持久化的任务可能会有一个相同的id.发生这样的问题的原因是因为id是由任务队列的默认id生成方法提供的.


新版本的api不需要兼容旧版本,我就有机会去修改上面遇到的问题了，这让我感到非常开心.我将```long```ids改成了任务生成的时候就分配一个```UUIDS```,这样做开发者就更加容易地将其他东西绑定到任务的生命周期里面去,而不需要完全依赖任务的返回值.这个故事里面最糟糕的事情是当我添加这个api的时候,我已经知道它是一个糟糕的api,但是我还是把这个api加上去了.所以无论应用场景是什么,千万不要随便添加新api.除非你已经为用户需要的功能想到了一个非常好的解决方案.

总的来说，开发新版本的是一个让我能够尝试新东西的非常有趣的经历.实际上还是有很多地方我是想修改的,但是最终我还是没有改,因为我需要在提供需求最高的api和兼容旧版本之间取一个平衡点.我对目前的版本非常满意,我希望你也能享受它，并且开发出最流畅的离线app.

[查看源码](http://github.com/yigit/android-priority-jobqueue)   

[阅读原文](http://www.birbit.com/rewriting-android-priority-jobqueue-lessons-learned/)
